@startuml System Sequence Diagram - Exception Handling & Recovery

!theme plain
skinparam sequenceMessageAlign center
skinparam sequenceArrowThickness 1
skinparam roundcorner 10
skinparam maxmessagesize 40

' Optimized for 4096px limit
skinparam dpi 72
skinparam scale 0.4
skinparam participantFontSize 8
skinparam participantFontStyle normal
skinparam participantBackgroundColor #E3F2FD
skinparam participantBorderColor #1976D2
skinparam participantBorderThickness 1
skinparam messageFontSize 7
skinparam messageFontStyle normal
skinparam messageColor #333333
skinparam noteBackgroundColor #FFF3CD
skinparam noteBorderColor #856404
skinparam noteBorderThickness 1
skinparam actorBackgroundColor #FFEBEE
skinparam actorBorderColor #D32F2F
skinparam actorBorderThickness 1

actor "Customer" as Customer
participant "Browser" as Browser
participant "Flask App" as Flask
participant "Quality Manager" as QTM
participant "Circuit Breaker" as CB
participant "Order Queue Manager" as Queue
participant "Metrics Engine" as Metrics
participant "Database" as DB

Customer -> Browser: Submit checkout during flash sale
Browser -> Flask: POST /checkout

note over Flask: Throttling & authentication
Flask -> QTM: throttle_request(user_id)
QTM --> Flask: allowed

note over Flask: Circuit Breaker Pattern
Flask -> QTM: execute_with_circuit_breaker(payment_func)
QTM -> CB: execute(payment_func)
CB -> DB: query CircuitBreakerState
DB --> CB: state = "CLOSED"
CB -> CB: process_payment()
CB --> QTM: Payment timeout error
QTM --> Flask: payment failed

note over Flask: Retry + MTTR tracking
Flask -> QTM: queue_order_for_retry(order_data)
QTM -> Queue: enqueue(order_data)
Queue -> DB: INSERT OrderQueue (status=pending)
DB --> Queue: queued
Queue --> QTM: queue_id
QTM --> Flask: order accepted for async processing
QTM -> Metrics: increment orders_submitted_total / accepted_total

note over CB
  Failure count >= threshold?
  - state flips to OPEN
  - record outage_start for MTTR
end note

CB -> DB: UPDATE CircuitBreakerState(state="OPEN")
CB -> Metrics: record_event(payment_circuit_opened)

Flask --> Browser: JSON {queued: true, message: "Payment retried asynchronously"}
Browser --> Customer: Show graceful degradation banner

== Background worker ==
participant "Async Worker" as Worker
Worker -> Queue: dequeue_order()
Queue -> DB: UPDATE OrderQueue(status="processing")
DB --> Queue: row locked
Queue --> Worker: order payload

Worker -> QTM: execute_with_circuit_breaker(payment_retry)
QTM -> CB: execute(payment_retry)
CB -> DB: check next_attempt_time
DB --> CB: allowed (HALF_OPEN)
CB -> CB: process_payment()
CB --> QTM: success, close breaker
CB -> Metrics: observe_latency(payment_circuit_mttr_seconds)
CB -> DB: UPDATE CircuitBreakerState(state="CLOSED")

Worker -> DB: UPDATE OrderQueue(status="completed")
Worker -> Metrics: observe_latency(order_processing_latency_ms)
Worker --> Flask: notify order completed

Flask --> Browser: JSON {success: true, sale_id: 124}
Browser --> Customer: Display confirmation

note right of Metrics
  Scenario dashboards consume:
  - orders_submitted_total / accepted_total
  - payment_circuit_mttr_seconds histogram
  - order_processing_latency_ms (p95 â‰¤ 500ms)
  - All timestamps normalized via Config.DEFAULT_TIMEZONE
end note

@enduml
